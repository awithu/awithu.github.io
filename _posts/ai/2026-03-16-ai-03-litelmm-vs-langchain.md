---
layout: post
title:  "개발자 입장에서 보는 LiteLLM과 LangChain의 차이"
date:   2026-03-16 09:00:00 +0900
categories: [IT, AI]
tags: [AI, LLM, LiteLLM, LangChain, 개발, 프레임워크]
description: "LiteLLM과 LangChain의 차이점을 개발자 관점에서 분석하고, 각각의 역할과 사용 시나리오를 정리합니다."
---

# 개발자 입장에서 보는 LiteLLM과 LangChain의 차이
"둘 중 하나를 고르는 문제는 아니었다"

LLM 기반 서비스를 만들다 보면
자연스럽게 **LiteLLM**과 **LangChain**을 접하게 된다.

처음엔 둘 다 "LLM을 쉽게 쓰게 해주는 라이브러리"처럼 보여서
비슷한 포지션이라고 오해하기 쉽다.

하지만 실제로 써보면,
이 둘은 해결하려는 문제가 꽤 다르다.

이 글에서는 기능 나열보다는
개발자 입장에서 어떤 역할을 맡기면 좋은지 위주로 정리해본다.

## LiteLLM: 모델 호출 계층을 정리하는 도구

LiteLLM은 애플리케이션 로직을 건드리지 않는다.
대신 **"어떤 모델을 어떻게 호출할 것인가"**에만 집중한다.

개발자 입장에서 체감되는 핵심은 단순하다.

- 여러 LLM(OpenAI, Claude, Gemini 등)을 같은 인터페이스로 호출
- 모델 변경 시 코드 수정 최소화
- 프록시로 사용할 경우 키 관리, 로깅, 라우팅 가능

눈에 띄는 기능은 많지 않지만,
모델을 교체하거나 비용을 신경 써야 하는 순간
존재감이 확실해진다.

👉 **LiteLLM은 인프라 성격의 도구에 가깝다.**

## LangChain: LLM 애플리케이션을 구성하는 프레임워크

LangChain은 방향이 다르다.
모델 호출 자체보다는,

**LLM이 어떤 흐름으로 동작해야 하는가**

를 코드로 표현하는 데 초점이 있다.

- Prompt → LLM → Tool → Output 구조
- RAG 구성
- 멀티 스텝 체인
- Agent 기반 로직

문서 검색 + 요약 + 질의응답처럼
단계가 늘어나는 작업에서는 확실히 편하다.

다만 단점도 명확하다.

- 작은 프로젝트에는 과할 수 있음
- 개념이 많아 러닝커브 존재
- 필요 이상으로 쓰면 구조가 복잡해짐

👉 **LangChain은 애플리케이션 로직 담당이다.**

## 그래서 선택은 어떻게 하나

LiteLLM과 LangChain을 비교 대상으로 놓는 경우가 많은데,
개인적으로는 이 질문 자체가 조금 어긋나 있다고 느꼈다.

현실적인 구조는 보통 이렇다.

```
LangChain (로직)
   ↓
LiteLLM (모델 호출)
   ↓
LLM Provider
```

- **LangChain**: 서비스 동작 방식
- **LiteLLM**: 모델 선택, 교체, 운영

역할을 분리해두면
모델 변경이나 비용 이슈가 생겼을 때
애플리케이션 코드에 미치는 영향을 줄일 수 있다.

## 개인적인 기준

정리하면 대략 이 정도다.

- **단순 호출 / 실험** → LiteLLM만 사용
- **멀티 스텝 로직** → LangChain
- **운영 전제 서비스** → LangChain + LiteLLM

정답이라기보다는,
몇 번 써보면서 가장 덜 불편했던 조합이다.

