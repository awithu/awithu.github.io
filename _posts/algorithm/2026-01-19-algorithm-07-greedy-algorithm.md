---
layout: post
title:  "ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ (Greedy Algorithm): ìˆœê°„ ìµœì„ ì˜ ì„ íƒ"
date:   2025-02-20 09:00:00 +0900
categories: [IT, ì•Œê³ ë¦¬ì¦˜]
tags: [ì•Œê³ ë¦¬ì¦˜, ê·¸ë¦¬ë””, íƒìš•ë²•, ìµœì í™”]
description: "ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ì›ë¦¬ì™€ ìµœì ì„± ì¦ëª…, ëŒ€í‘œ ë¬¸ì œë“¤ì„ ë°°ì›ë‹ˆë‹¤."
---

# ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ (Greedy Algorithm): ìˆœê°„ ìµœì„ ì˜ ì„ íƒ

í”„ë¡œê·¸ë˜ë°ì—ì„œ ê°€ì¥ ì§ê´€ì ì´ê³  ìš°ì•„í•œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ê°€ ë°”ë¡œ **ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜(Greedy Algorithm)**ì…ë‹ˆë‹¤. ë§ ê·¸ëŒ€ë¡œ "ìš•ì‹¬ìŸì´"ì²˜ëŸ¼ ë§¤ ìˆœê°„ ìµœì„ ì˜ ì„ íƒì„ í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ì´ë²ˆ ê¸€ì—ì„œëŠ” ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ì›ë¦¬ì™€ í•œê³„, ê·¸ë¦¬ê³  ëŒ€í‘œì ì¸ ë¬¸ì œë“¤ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

## 1. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ì´ˆ ê°œë…

### ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ì •ì˜
**ê° ë‹¨ê³„ì—ì„œ ìˆœê°„ì ìœ¼ë¡œ ìµœì„ ì˜ ì„ íƒ**ì„ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ë¯¸ë˜ë¥¼ ë‚´ë‹¤ë³´ì§€ ì•Šê³  í˜„ì¬ ìƒí™©ì—ì„œ ê°€ì¥ ì¢‹ì€ ì„ íƒì„ ë°˜ë³µí•©ë‹ˆë‹¤.

### ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ íŠ¹ì§•
1. **ë‹¨ìˆœí•¨**: êµ¬í˜„ì´ ê°„ë‹¨í•˜ê³  ì§ê´€ì 
2. **íš¨ìœ¨ì„±**: ì¼ë°˜ì ìœ¼ë¡œ ë¹ ë¥¸ ì‹¤í–‰ ì‹œê°„
3. **ê·¼ì‹œì•ˆì **: ë¯¸ë˜ ê²°ê³¼ë¥¼ ê³ ë ¤í•˜ì§€ ì•ŠìŒ

### ê·¸ë¦¬ë”” vs ë™ì  ê³„íšë²•
- **ê·¸ë¦¬ë””**: í•œ ë²ˆì˜ ì„ íƒìœ¼ë¡œ ë (ê²°ì •ë¡ ì )
- **ë™ì  ê³„íšë²•**: ëª¨ë“  ê°€ëŠ¥ì„±ì„ ê³ ë ¤ (ì™„ì „ íƒìƒ‰)

## 2. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ì‘ë™ ì›ë¦¬

### ìµœì  ë¶€ë¶„ êµ¬ì¡° (Optimal Substructure)
ì „ì²´ ë¬¸ì œì˜ ìµœì í•´ê°€ ë¶€ë¶„ ë¬¸ì œì˜ ìµœì í•´ë¡œ êµ¬ì„±ë  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

### ê·¸ë¦¬ë”” ì„ íƒ ì†ì„± (Greedy Choice Property)
**ì§€ì—­ì  ìµœì  ì„ íƒ**ì´ ì „ì—­ì  ìµœì í•´ë¡œ ì´ì–´ì ¸ì•¼ í•©ë‹ˆë‹¤.

### ì˜ˆì‹œ: ë™ì „ ê±°ìŠ¤ë¦„ëˆ
```
ë™ì „: [1, 5, 10, 25]ì›
ê±°ìŠ¤ë¦„ëˆ: 36ì›

ê·¸ë¦¬ë”” ì„ íƒ:
25ì› â†’ 1ê°œ (ë‚¨ì€ ê¸ˆì•¡: 11ì›)
10ì› â†’ 1ê°œ (ë‚¨ì€ ê¸ˆì•¡: 1ì›)
1ì› â†’ 1ê°œ (ë‚¨ì€ ê¸ˆì•¡: 0ì›)

ê²°ê³¼: 3ê°œì˜ ë™ì „
```

## 3. ëŒ€í‘œì ì¸ ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë“¤

### 1. í™œë™ ì„ íƒ ë¬¸ì œ (Activity Selection Problem)

**ë¬¸ì œ**: ê²¹ì¹˜ì§€ ì•ŠëŠ” ìµœëŒ€ ê°œìˆ˜ì˜ í™œë™ì„ ì„ íƒí•˜ì„¸ìš”.

```python
def activity_selection(activities):
    """
    í™œë™ ì„ íƒ ë¬¸ì œ í•´ê²° (ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜)

    Args:
        activities (list): [(ì‹œì‘ì‹œê°„, ì¢…ë£Œì‹œê°„), ...] í˜•íƒœì˜ í™œë™ ë¦¬ìŠ¤íŠ¸

    Returns:
        list: ì„ íƒëœ í™œë™ë“¤ì˜ ì¸ë±ìŠ¤
    """
    # ì¢…ë£Œ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    activities.sort(key=lambda x: x[1])

    selected = [0]  # ì²« ë²ˆì§¸ í™œë™ ì„ íƒ
    last_end_time = activities[0][1]

    for i in range(1, len(activities)):
        if activities[i][0] >= last_end_time:
            selected.append(i)
            last_end_time = activities[i][1]

    return selected

# í…ŒìŠ¤íŠ¸
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
selected_indices = activity_selection(activities)

print("ì„ íƒëœ í™œë™ë“¤:")
for idx in selected_indices:
    start, end = activities[idx]
    print(f"í™œë™ {idx}: {start}ì‹œ - {end}ì‹œ")
```

### 2. í—ˆí”„ë§Œ ì½”ë”© (Huffman Coding)

**ë¬¸ì œ**: ë¬¸ìì˜ ë¹ˆë„ì— ë”°ë¼ ìµœì ì˜ ì´ì§„ ì½”ë“œë¥¼ ìƒì„±í•˜ì„¸ìš”.

```python
import heapq
from collections import defaultdict

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(text):
    """
    í—ˆí”„ë§Œ íŠ¸ë¦¬ êµ¬ì¶•

    Args:
        text (str): ì••ì¶•í•  í…ìŠ¤íŠ¸

    Returns:
        HuffmanNode: í—ˆí”„ë§Œ íŠ¸ë¦¬ì˜ ë£¨íŠ¸
    """
    # ë¹ˆë„ ê³„ì‚°
    freq = defaultdict(int)
    for char in text:
        freq[char] += 1

    # ìš°ì„ ìˆœìœ„ í ìƒì„±
    pq = [HuffmanNode(char, count) for char, count in freq.items()]
    heapq.heapify(pq)

    # í—ˆí”„ë§Œ íŠ¸ë¦¬ êµ¬ì¶•
    while len(pq) > 1:
        # ë¹ˆë„ê°€ ê°€ì¥ ì‘ì€ ë‘ ë…¸ë“œ ì¶”ì¶œ
        left = heapq.heappop(pq)
        right = heapq.heappop(pq)

        # ìƒˆë¡œìš´ ë‚´ë¶€ ë…¸ë“œ ìƒì„±
        internal = HuffmanNode(None, left.freq + right.freq)
        internal.left = left
        internal.right = right

        heapq.heappush(pq, internal)

    return pq[0]

def generate_codes(node, current_code="", codes=None):
    """
    í—ˆí”„ë§Œ ì½”ë“œë¥¼ ìƒì„±

    Args:
        node (HuffmanNode): íŠ¸ë¦¬ì˜ í˜„ì¬ ë…¸ë“œ
        current_code (str): í˜„ì¬ê¹Œì§€ì˜ ì½”ë“œ
        codes (dict): ë¬¸ìë³„ ì½”ë“œë¥¼ ì €ì¥í•  ë”•ì…”ë„ˆë¦¬

    Returns:
        dict: ë¬¸ìë³„ í—ˆí”„ë§Œ ì½”ë“œ
    """
    if codes is None:
        codes = {}

    if node is None:
        return codes

    if node.char is not None:  # ë¦¬í”„ ë…¸ë“œ
        codes[node.char] = current_code
        return codes

    # ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì¬ê·€ í˜¸ì¶œ
    generate_codes(node.left, current_code + "0", codes)
    generate_codes(node.right, current_code + "1", codes)

    return codes

# í…ŒìŠ¤íŠ¸
text = "hello world"
root = build_huffman_tree(text)
codes = generate_codes(root)

print("í—ˆí”„ë§Œ ì½”ë“œ:")
for char, code in codes.items():
    print(f"'{char}': {code}")
```

### 3. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ - í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜

**ë¬¸ì œ**: ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ìµœì†Œ ë¹„ìš© íŠ¸ë¦¬ë¥¼ ì°¾ìœ¼ì„¸ìš”.

```python
def find(parent, i):
    """Union-Findì˜ Find ì—°ì‚°"""
    if parent[i] != i:
        parent[i] = find(parent, parent[i])  # ê²½ë¡œ ì••ì¶•
    return parent[i]

def union(parent, rank, x, y):
    """Union-Findì˜ Union ì—°ì‚°"""
    xroot = find(parent, x)
    yroot = find(parent, y)

    if rank[xroot] < rank[yroot]:
        parent[xroot] = yroot
    elif rank[xroot] > rank[yroot]:
        parent[yroot] = xroot
    else:
        parent[yroot] = xroot
        rank[xroot] += 1

def kruskal_mst(edges, num_vertices):
    """
    í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ MST êµ¬í•˜ê¸°

    Args:
        edges (list): [(ê°€ì¤‘ì¹˜, ì •ì 1, ì •ì 2), ...] í˜•íƒœì˜ ê°„ì„  ë¦¬ìŠ¤íŠ¸
        num_vertices (int): ì •ì  ê°œìˆ˜

    Returns:
        list: MSTë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤
    """
    # ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    edges.sort()

    parent = list(range(num_vertices))
    rank = [0] * num_vertices
    mst = []

    for weight, u, v in edges:
        # ì‚¬ì´í´ì´ ìƒì„±ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ê°„ì„  ì¶”ê°€
        if find(parent, u) != find(parent, v):
            union(parent, rank, u, v)
            mst.append((u, v, weight))

    return mst

# í…ŒìŠ¤íŠ¸
edges = [
    (7, 0, 1), (5, 0, 3), (8, 1, 2), (9, 1, 3),
    (7, 1, 4), (5, 2, 4), (15, 3, 4), (6, 4, 5),
    (8, 2, 5), (9, 3, 5), (11, 4, 5)
]

mst = kruskal_mst(edges, 6)
total_weight = sum(weight for _, _, weight in mst)

print("ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬:")
for u, v, weight in mst:
    print(f"ê°„ì„  ({u}, {v}): ê°€ì¤‘ì¹˜ {weight}")
print(f"ì´ ê°€ì¤‘ì¹˜: {total_weight}")
```

## 4. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ í•œê³„ì™€ í•´ê²°ì±…

### ê·¸ë¦¬ë””ê°€ ì‹¤íŒ¨í•˜ëŠ” ê²½ìš°

**ì˜ˆì‹œ 1: ë™ì „ ê±°ìŠ¤ë¦„ëˆ (íŠ¹ì • ë™ì „ ì¡°í•©)**
```
ë™ì „: [1, 3, 4]ì›
ê±°ìŠ¤ë¦„ëˆ: 6ì›

ê·¸ë¦¬ë”” ì„ íƒ:
4ì› â†’ 1ê°œ (ë‚¨ì€ ê¸ˆì•¡: 2ì›)
1ì› â†’ 2ê°œ (ë‚¨ì€ ê¸ˆì•¡: 0ì›)
ì´ ë™ì „: 3ê°œ

ìµœì í•´:
3ì› â†’ 2ê°œ
ì´ ë™ì „: 2ê°œ
```

**ì˜ˆì‹œ 2: ë°°ë‚­ ë¬¸ì œ (ì¼ë¶€ ì„ íƒ ê°€ëŠ¥)**
```
ë¬¼ê±´: [(ë¬´ê²Œ, ê°€ì¹˜)] = [(2, 3), (3, 4), (4, 5), (5, 6)]
ìš©ëŸ‰: 5

ê·¸ë¦¬ë”” (ê°€ì¹˜ ê¸°ì¤€):
ë¬¼ê±´ 4 (ê°€ì¹˜ 6, ë¬´ê²Œ 5) â†’ ì„ íƒ
ì´ ê°€ì¹˜: 6

ìµœì í•´:
ë¬¼ê±´ 1 (ê°€ì¹˜ 3, ë¬´ê²Œ 2) + ë¬¼ê±´ 2 (ê°€ì¹˜ 4, ë¬´ê²Œ 3) = ê°€ì¹˜ 7
```

### ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ê²€ì¦ ë°©ë²•

#### 1. ìµœì ì„± ì¦ëª… (Optimal Substructure)
- ì „ì²´ ìµœì í•´ê°€ ë¶€ë¶„ ìµœì í•´ë¡œ êµ¬ì„±ë˜ëŠ”ì§€ ì¦ëª…

#### 2. ê·¸ë¦¬ë”” ì„ íƒ ì¦ëª… (Greedy Choice Property)
- ì²« ë²ˆì§¸ ì„ íƒì´ í•­ìƒ ìµœì í•´ì— í¬í•¨ë˜ëŠ”ì§€ ì¦ëª…

#### 3. ê·€ë‚©ë²• ì ìš©
- ì‘ì€ ë¬¸ì œì—ì„œ ì„±ë¦½í•˜ë©´ í° ë¬¸ì œì—ì„œë„ ì„±ë¦½í•¨ì„ ì¦ëª…

## 5. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ íŒ¨í„´

### 1. ë¬¸ì œ ë¶„ì„
- **ê·¸ë¦¬ë”” ì„ íƒ ê°€ëŠ¥ì„±** í™•ì¸
- **ìµœì  ë¶€ë¶„ êµ¬ì¡°** í™•ì¸
- **ë°˜ë¡€ ì¡´ì¬ ì—¬ë¶€** í™•ì¸

### 2. ê·¸ë¦¬ë”” ì „ëµ ì„ íƒ
- **ê°€ì¥ í° ê²ƒë¶€í„°**: í—ˆí”„ë§Œ ì½”ë”©, í¬ë£¨ìŠ¤ì¹¼
- **ê°€ì¥ ì‘ì€ ê²ƒë¶€í„°**: ë‹¤ìµìŠ¤íŠ¸ë¼, í—ˆí”„ë§Œ
- **ê°€ì¥ ì´ë¥¸ ì¢…ë£Œ ì‹œê°„**: í™œë™ ì„ íƒ

### 3. êµ¬í˜„ ë° ê²€ì¦
- **ì˜ì‚¬ì½”ë“œ ì‘ì„±**
- **ë°˜ë¡€ í…ŒìŠ¤íŠ¸**
- **ì •ë‹¹ì„± ì¦ëª…**

## 6. ê³ ê¸‰ ê·¸ë¦¬ë”” ê¸°ë²•

### 1. ìš°ì„ ìˆœìœ„ í í™œìš©
```python
import heapq

def dijkstra_shortest_path(graph, start):
    """
    ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ (ê·¸ë¦¬ë”” + ìš°ì„ ìˆœìœ„ í)

    Args:
        graph (dict): ê·¸ë˜í”„ (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸)
        start (int): ì‹œì‘ ì •ì 

    Returns:
        dict: ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
    """
    distances = {node: float('inf') for node in graph}
    distances[start] = 0

    pq = [(0, start)]  # (ê±°ë¦¬, ì •ì )

    while pq:
        current_distance, current_node = heapq.heappop(pq)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances
```

### 2. ê·¸ë¦¬ë”” + DP í•˜ì´ë¸Œë¦¬ë“œ
```python
def fractional_knapsack(items, capacity):
    """
    ë¶„í•  ê°€ëŠ¥ ë°°ë‚­ ë¬¸ì œ (ê·¸ë¦¬ë””)

    Args:
        items (list): [(ë¬´ê²Œ, ê°€ì¹˜), ...]
        capacity (int): ë°°ë‚­ ìš©ëŸ‰

    Returns:
        float: ìµœëŒ€ ê°€ì¹˜
    """
    # ë‹¨ìœ„ ë¬´ê²Œë‹¹ ê°€ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    items.sort(key=lambda x: x[1] / x[0], reverse=True)

    total_value = 0
    remaining_capacity = capacity

    for weight, value in items:
        if remaining_capacity >= weight:
            # ë¬¼ê±´ ì „ì²´ ì„ íƒ
            total_value += value
            remaining_capacity -= weight
        else:
            # ë¬¼ê±´ ì¼ë¶€ ì„ íƒ
            fraction = remaining_capacity / weight
            total_value += value * fraction
            break

    return total_value
```

## 7. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í•´ê²° ì „ëµ

### 1. ê·¸ë¦¬ë”” ê°€ëŠ¥ì„± íŒë‹¨
- **ë§¤íŠ¸ë¡œì´ë“œ**: ê·¸ë¦¬ë””ê°€ ìµœì í•´ë¥¼ ë³´ì¥í•˜ëŠ” êµ¬ì¡°
- **ë§¤íŠ¸ë¡œì´ë“œ ì™¸**: ë°˜ë¡€ ì¡´ì¬ ê°€ëŠ¥ì„± ë†’ìŒ

### 2. ì¦ëª… ê¸°ë²•
- **êµí™˜è®ºè¯**: ê·¸ë¦¬ë”” ì„ íƒì´ ë‹¤ë¥¸ ì„ íƒë³´ë‹¤ ìš°ì›”í•¨ ì¦ëª…
- **ê·€ë‚©ë²•**: ì‘ì€ ê²½ìš°ì—ì„œ í° ê²½ìš°ë¡œ í™•ì¥

### 3. êµ¬í˜„ íŒ
- **ì •ë ¬ í™œìš©**: ëŒ€ë¶€ë¶„ì˜ ê·¸ë¦¬ë””ëŠ” ì •ë ¬ë¡œ ì‹œì‘
- **ìš°ì„ ìˆœìœ„ í**: ì‹¤ì‹œê°„ ì„ íƒì´ í•„ìš”í•  ë•Œ
- **ë°˜ë¡€ í…ŒìŠ¤íŠ¸**: êµ¬í˜„ í›„ ë‹¤ì–‘í•œ ì¼€ì´ìŠ¤ë¡œ ê²€ì¦

## 8. ì—°ìŠµ ë¬¸ì œ

1. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì´ ì‹¤íŒ¨í•˜ëŠ” ë™ì „ ê±°ìŠ¤ë¦„ëˆ ë¬¸ì œë¥¼ ì°¾ì•„ë³´ì„¸ìš”.

2. í—ˆí”„ë§Œ ì½”ë”©ì—ì„œ ë¹ˆë„ê°€ ê°™ì€ ë¬¸ìë“¤ì˜ ìš°ì„ ìˆœìœ„ëŠ” ì–´ë–»ê²Œ ê²°ì •ë˜ë‚˜ìš”?

3. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œ Union-Find ìë£Œêµ¬ì¡°ê°€ ì™œ í•„ìš”í•œê°€ìš”?

4. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œì˜ ì˜ˆì‹œë¥¼ ë“¤ì–´ë³´ì„¸ìš”.

## ë§ˆë¬´ë¦¬

ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì€ ë‹¨ìˆœí•˜ì§€ë§Œ ê°•ë ¥í•œ ë¬¸ì œ í•´ê²° ë„êµ¬ì…ë‹ˆë‹¤. ëª¨ë“  ë¬¸ì œì— ì ìš©í•  ìˆ˜ëŠ” ì—†ì§€ë§Œ, ì ìš© ê°€ëŠ¥í•œ ë¬¸ì œì—ì„œëŠ” ë§¤ìš° íš¨ìœ¨ì ì…ë‹ˆë‹¤.

**í•µì‹¬ ìš”ì•½:**
- ê·¸ë¦¬ë”” = ìˆœê°„ ìµœì„ ì˜ ì„ íƒ ë°˜ë³µ
- ì „ì œ ì¡°ê±´: ìµœì  ë¶€ë¶„ êµ¬ì¡° + ê·¸ë¦¬ë”” ì„ íƒ ì†ì„±
- ëŒ€í‘œ ë¬¸ì œ: í™œë™ ì„ íƒ, í—ˆí”„ë§Œ ì½”ë”©, í¬ë£¨ìŠ¤ì¹¼
- í•œê³„: ë¯¸ë˜ ê³ ë ¤ ë¶ˆê°€, ë°˜ë¡€ ì¡´ì¬ ê°€ëŠ¥
- ê²€ì¦: ìµœì ì„± ì¦ëª… + ë°˜ë¡€ í…ŒìŠ¤íŠ¸

ë‹¤ìŒ ê¸€ì—ì„œëŠ” **ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜**ì— ëŒ€í•´ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•˜ëŠ” ì²´ê³„ì ì¸ ë°©ë²•ì„ ë°°ì›Œë³´ê² ìŠµë‹ˆë‹¤!

**ì¶”ê°€ íŒ:** ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ê¸° ì „ì— ë¨¼ì € ë°˜ë¡€ë¥¼ ì°¾ì•„ë³´ì„¸ìš”. ê·¸ë¦¬ë””ê°€ í•­ìƒ ì˜³ì€ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤! ğŸ¯ğŸ’¡
